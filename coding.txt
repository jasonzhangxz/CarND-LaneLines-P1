# TODO: Build your pipeline that will draw lane lines on the test_images
# then save them to the test_images directory.

for imageName in os.listdir("test_images/"):
    file = "test_images/"+imageName
    image = mpimg.imread(file)

    # grayscale the image
    gray = grayscale(image); 

    #apply gaussian smoothing
    kernel_size = 5
    blur_gray = gaussian_blur(gray, kernel_size)

    # Define parameters for Canny and apply
    low_threshold = 70
    high_threshold = 150
    edges = canny(blur_gray, low_threshold, high_threshold)

    #create the mask to care only about the ROI
    imshape = image.shape
    vertices = np.array([[(0,imshape[0]),(460, 325), (500, 325), (imshape[1],imshape[0])]], dtype=np.int32)
    masked_img = region_of_interest(edges, vertices)

    #define hugh transformation parameters
    rho = 2 # distance resolution in pixels of the Hough grid
    theta = np.pi/180 # angular resolution in radians of the Hough grid
    threshold = 10     # minimum number of votes (intersections in Hough grid cell)
    min_line_length = 25 #minimum number of pixels making up a line
    max_line_gap = 20    # maximum gap in pixels between connectable line segments

    # Run Hough on edge detected image and draw the detected line segments on a blank copy 
    line_image = hough_lines(masked_img, rho, theta, threshold, min_line_length, max_line_gap)

    final_img = weighted_img(line_image, image)
    
    cv2.imwrite("test_images_output/"+imageName,final_img)

#     plt.imshow(final_img)
